main:
  params: [args]
  steps:
    - init:
        assign:
          - baseUrl: ${args.baseUrl}
          - tenantId: ${args.tenantId}
          - internalKey: ${args.internalApiKey}
          - headers:
              Content-Type: "application/json"
              X-Internal-Key: ${internalKey}

    - provision_database:
        try:
          call: http.post
          args:
            url: ${baseUrl + "/internal/provisioning/database"}
            headers: ${headers}
            body:
              tenantId: ${tenantId}
            auth:
              type: OIDC
          result: db_result
        except:
          as: e
          steps:
            - rollback_db:
                call: perform_rollback
                args:
                  baseUrl: ${baseUrl}
                  headers: ${headers}
                  tenantId: ${tenantId}
            - raise_db_error:
                raise: ${e}

    - ensure_migration_job:
        try:
          call: http.post
          args:
            url: ${baseUrl + "/internal/provisioning/migrations"}
            headers: ${headers}
            query:
              action: "ensure"
            body:
              tenantId: ${tenantId}
            auth:
              type: OIDC
          result: ensure_job_result
        except:
          as: e
          steps:
            - rollback_ensure:
                call: perform_rollback
                args:
                  baseUrl: ${baseUrl}
                  headers: ${headers}
                  tenantId: ${tenantId}
            - raise_ensure_error:
                raise: ${e}

    - check_ensure_op_start:
        switch:
          - condition: ${"operationName" in ensure_job_result.body}
            next: wait_for_ensure_op
          - condition: true
            next: trigger_migrations

    - wait_for_ensure_op:
        call: sys.sleep
        args:
          seconds: 5

    - check_ensure_op_status:
        try:
          call: http.get
          args:
            url: ${baseUrl + "/internal/provisioning/operations"}
            headers: ${headers}
            query:
              name: ${ensure_job_result.body.operationName}
            auth:
              type: OIDC
          result: ensure_op_status
        except:
          as: e
          steps:
            - raise_ensure_status_error:
                raise: ${e}

    - evaluate_ensure_op:
        switch:
          - condition: ${ensure_op_status.body.done}
            next: trigger_migrations
          - condition: true
            next: wait_for_ensure_op

    - trigger_migrations:
        try:
          call: http.post
          args:
            url: ${baseUrl + "/internal/provisioning/migrations"}
            headers: ${headers}
            query:
              action: "trigger"
            body:
              tenantId: ${tenantId}
            auth:
              type: OIDC
          result: trigger_job_result
        except:
          as: e
          steps:
            - rollback_trigger:
                call: perform_rollback
                args:
                  baseUrl: ${baseUrl}
                  headers: ${headers}
                  tenantId: ${tenantId}
            - raise_trigger_error:
                raise: ${e}

    - wait_for_trigger_op:
        call: sys.sleep
        args:
          seconds: 5

    - check_trigger_op_status:
        try:
          call: http.get
          args:
            url: ${baseUrl + "/internal/provisioning/operations"}
            headers: ${headers}
            query:
              name: ${trigger_job_result.body.operationName}
            auth:
              type: OIDC
          result: trigger_op_status
        except:
          as: e
          steps:
            - raise_trigger_status_error:
                raise: ${e}

    - evaluate_trigger_op:
        switch:
          - condition: ${trigger_op_status.body.done AND "error" in trigger_op_status.body}
            steps:
              - rollback_trigger_error:
                  call: perform_rollback
                  args:
                    baseUrl: ${baseUrl}
                    headers: ${headers}
                    tenantId: ${tenantId}
              - raise_trigger_op_error:
                  raise: '${"Migration trigger operation failed: " + default(trigger_op_status.body.error.message, "Unknown error")}'
          - condition: ${trigger_op_status.body.done}
            assign:
              - executionName: ${trigger_op_status.body.response.name}
            next: wait_for_migrations
          - condition: true
            next: wait_for_trigger_op

    - wait_for_migrations:
        call: sys.sleep
        args:
          seconds: 10

    - check_migration_status:
        try:
          call: http.get
          args:
            url: ${baseUrl + "/internal/provisioning/migrations/status"}
            headers: ${headers}
            query:
              name: ${executionName}
            auth:
              type: OIDC
          result: status_response
        except:
          as: e
          steps:
            - rollback_check:
                call: perform_rollback
                args:
                  baseUrl: ${baseUrl}
                  headers: ${headers}
                  tenantId: ${tenantId}
            - raise_check_error:
                raise: ${e}

    - evaluate_migration:
        switch:
          - condition: ${status_response.body.status == "running"}
            next: wait_for_migrations
          - condition: ${status_response.body.status == "success"}
            next: deploy_service
          - condition: ${status_response.body.status == "failed"}
            steps:
              - rollback_logic_failure:
                  call: perform_rollback
                  args:
                    baseUrl: ${baseUrl}
                    headers: ${headers}
                    tenantId: ${tenantId}
              - raise_migration_failed:
                  raise: '${"Migration failed: " + default(status_response.body.error, "Unknown error")}'
    - deploy_service:
        try:
          call: http.post
          args:
            url: ${baseUrl + "/internal/provisioning/service"}
            headers: ${headers}
            body:
              tenantId: ${tenantId}
            auth:
              type: OIDC
          result: deploy_start_result
        except:
          as: e
          steps:
            - rollback_service_start:
                call: perform_rollback
                args:
                  baseUrl: ${baseUrl}
                  headers: ${headers}
                  tenantId: ${tenantId}
            - raise_service_start_error:
                raise: ${e}

    - wait_for_deploy_op:
        call: sys.sleep
        args:
          seconds: 5

    - check_deploy_op_status:
        try:
          call: http.get
          args:
            url: ${baseUrl + "/internal/provisioning/operations"}
            headers: ${headers}
            query:
              name: ${deploy_start_result.body.operationName}
            auth:
              type: OIDC
          result: deploy_op_status
        except:
          as: e
          steps:
            - raise_deploy_status_error:
                raise: ${e}

    - evaluate_deploy_op:
        switch:
          - condition: ${deploy_op_status.body.done AND "error" in deploy_op_status.body}
            steps:
              - rollback_deploy_error:
                  call: perform_rollback
                  args:
                    baseUrl: ${baseUrl}
                    headers: ${headers}
                    tenantId: ${tenantId}
              - raise_deploy_op_error:
                  raise: '${"Service deployment operation failed: " + default(deploy_op_status.body.error.message, "Unknown error")}'
          - condition: ${deploy_op_status.body.done}
            next: finalize_service
          - condition: true
            next: wait_for_deploy_op

    - finalize_service:
        try:
          call: http.post
          args:
            url: ${baseUrl + "/internal/provisioning/service/finalize"}
            headers: ${headers}
            body:
              tenantId: ${tenantId}
            auth:
              type: OIDC
          result: service_result
        except:
          as: e
          steps:
            - rollback_service_finalize:
                call: perform_rollback
                args:
                  baseUrl: ${baseUrl}
                  headers: ${headers}
                  tenantId: ${tenantId}
            - raise_service_finalize_error:
                raise: ${e}

    - configure_domain:
        try:
          call: http.post
          args:
            url: ${baseUrl + "/internal/provisioning/domain"}
            headers: ${headers}
            body:
              tenantId: ${tenantId}
            auth:
              type: OIDC
          result: domain_result
        except:
          as: e
          steps:
            - rollback_domain:
                call: perform_rollback
                args:
                  baseUrl: ${baseUrl}
                  headers: ${headers}
                  tenantId: ${tenantId}
            - raise_domain_error:
                raise: ${e}

    - activate_tenant:
        try:
          call: http.post
          args:
            url: ${baseUrl + "/internal/provisioning/activate"}
            headers: ${headers}
            body:
              tenantId: ${tenantId}
            auth:
              type: OIDC
          result: activation_result
        except:
          as: e
          steps:
            - rollback_activation:
                call: perform_rollback
                args:
                  baseUrl: ${baseUrl}
                  headers: ${headers}
                  tenantId: ${tenantId}
            - raise_activation_error:
                raise: ${e}

    - return_result:
        return:
          status: "success"
          tenantId: ${tenantId}

perform_rollback:
  params: [baseUrl, headers, tenantId]
  steps:
    - call_rollback_endpoint:
        try:
          call: http.post
          args:
            url: ${baseUrl + "/internal/provisioning/rollback"}
            headers: ${headers}
            body:
              tenantId: ${tenantId}
            auth:
              type: OIDC
          result: rollback_result
        except:
          as: e
          # If rollback initiation fails, we just return (best effort)
          return: "failed to initiate rollback"

    - check_rollback_op:
        switch:
          - condition: ${"operationName" in rollback_result.body}
            next: wait_for_rollback_op
          - condition: true
            return: "rollback initiated (no wait)"

    - wait_for_rollback_op:
        call: sys.sleep
        args:
          seconds: 5

    - check_rollback_status:
        try:
          call: http.get
          args:
            url: ${baseUrl + "/internal/provisioning/operations"}
            headers: ${headers}
            query:
              name: ${rollback_result.body.operationName}
            auth:
              type: OIDC
          result: rollback_op_status
        except:
          as: e
          return: "rollback status check failed"

    - evaluate_rollback_op:
        switch:
          - condition: ${rollback_op_status.body.done}
            return: "rollback completed"
          - condition: true
            next: wait_for_rollback_op
