---
description: Neon database provisioning patterns and management.
globs: apps/control-plane/**/*
---
# Database Infrastructure Rules

## Database Isolation (Non-Negotiable)

- **NEVER** share databases between tenants
- Each tenant **MUST** have a dedicated Neon PostgreSQL database
- Physical isolation required, not logical separation

## Database Provisioning Pattern

The Control Plane creates databases programmatically via Neon API:

```typescript
// Create new Neon database for tenant
const database = await neonApi.createDatabase({
  projectId: NEON_PROJECT_ID,
  branch: {
    name: `tenant-${tenantId}`
  }
});

// Store connection string in Secret Manager
await secretManager.createSecret({
  name: `tenant-${tenantId}-db-url`,
  value: database.connectionString
});
```

## Connection String Management

- Store connection strings in GCP Secret Manager
- Secret naming: `tenant-{tenantId}-db-url`
- Grant access to tenant instance service account
- Never log or expose connection strings

## Database Configuration

- **Provider**: Neon Serverless PostgreSQL
- **Project**: Single Neon project for all tenant databases
- **Isolation**: One database per tenant (physical separation)
- **Region**: Configure per tenant requirements
- **Backup**: Automated daily backups via Neon

## Connection Pattern

Tenant instances connect to their isolated database:

```typescript
// In tenant instance
const databaseUrl = process.env.DATABASE_URL; // From Secret Manager
const db = drizzle(neon(databaseUrl), { schema });
```

## Cleanup

When deleting a tenant:
```typescript
// Delete database via Neon API
await neonApi.deleteDatabase({
  projectId: NEON_PROJECT_ID,
  branchId: tenantDatabase.branchId
});

// Delete secret
await secretManager.deleteSecret(`tenant-${tenantId}-db-url`);
```
