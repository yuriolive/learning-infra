# Cursor Rules for Multi-Tenant E-commerce Platform

## Project Context

Multi-tenant e-commerce platform using MedusaJS 2.0 with multi-instance provisioning. Each merchant gets a dedicated backend and database. See `AGENTS.md` for detailed architecture.

## Core Principles

### Multi-Instance Model (Non-Negotiable)
- **NEVER** use shared-database multi-tenancy
- Each tenant: dedicated Neon PostgreSQL database + isolated Google Cloud Run compute
- Physical isolation required, not just logical

### Serverless-First
- All infrastructure must be serverless (Neon, Upstash Redis, Cloud Run with `min-instances: 0`, Cloudflare R2)

### Technology Stack
- **Backend**: MedusaJS 2.0+ (TypeScript only)
- **Frontend**: Next.js on Cloudflare Pages
- **Database**: Neon Serverless PostgreSQL
- **Cache**: Upstash Redis
- **DNS/SSL**: Cloudflare for SaaS

## Code Organization

```
/
├── control-plane/          # Orchestrator API (tenant provisioning)
├── tenant-instance/        # MedusaJS template/boilerplate
├── storefront/             # Next.js multi-tenant storefront
├── infrastructure/         # Infrastructure as Code
└── shared/                 # Shared utilities, types, constants
```

## Coding Standards

### TypeScript
- Use TypeScript for ALL backend code (strict mode)
- Prefer interfaces over types for public APIs
- Use async/await, avoid callbacks

### Database
- Each tenant has unique `DATABASE_URL` (never shared)
- Connection pooling per tenant instance
- Store connection strings securely (env vars or secrets manager)

### API Design
- Control Plane: RESTful endpoints for tenant management
- Tenant API: Standard MedusaJS REST/GraphQL
- Storefront: Next.js API routes with hostname-based routing

### Error Handling
- Proper error types and messages
- Log with tenant context when applicable
- Never expose internal errors to end users
- Retry logic for infrastructure operations

## Key Requirements

- **Performance**: Store provisioning < 2 minutes, Cloud Run `min-instances: 0`, optimize cold starts
- **Security**: Strict tenant isolation, GCP Secret Manager, proper auth, never log sensitive data
- **Testing**: Unit tests for provisioning, tenant isolation tests, integration tests, performance tests

## Common Patterns

### Tenant Resolution (Storefront)
```typescript
// Resolve tenant from hostname/subdomain
const tenantId = getTenantFromHostname(request.headers.host);
const tenantApiUrl = await getTenantApiUrl(tenantId);
```

### Database Provisioning (Control Plane)
```typescript
// Create new Neon database for tenant
const database = await neonApi.createDatabase({
  name: `tenant-${tenantId}`,
  region: 'us-east-1'
});
```

## What NOT to Do

❌ **NEVER** share databases between tenants
❌ **NEVER** use shared-database multi-tenancy patterns
❌ **NEVER** hardcode tenant IDs or connection strings
❌ **NEVER** skip tenant isolation checks
❌ **NEVER** use non-serverless infrastructure without justification
❌ **NEVER** write backend code in JavaScript (use TypeScript)
❌ **NEVER** expose tenant data to other tenants

## What to Do

✅ **ALWAYS** maintain physical database isolation
✅ **ALWAYS** use TypeScript for backend code
✅ **ALWAYS** implement proper error handling
✅ **ALWAYS** test tenant isolation
✅ **ALWAYS** use serverless infrastructure
✅ **ALWAYS** configure scale-to-zero for Cloud Run
✅ **ALWAYS** store secrets securely
✅ **ALWAYS** log with tenant context when applicable

## Development Workflow

1. Identify component (control-plane/tenant-instance/storefront)
2. Check tenant isolation is maintained
3. Test with multiple tenant contexts
4. Verify provisioning time < 2 minutes
5. Update tests
6. Document changes

## Documentation and Research

**ALWAYS** use context7 MCP (if available) for documentation searches. Use for: MedusaJS 2.0, Neon API, Google Cloud Run, Cloudflare for SaaS, Next.js edge functions, Upstash Redis. Prefer over web searches for library-specific docs. See `AGENTS.md` for detailed guidance.

## Code Review Checklist

- [ ] Tenant isolation maintained?
- [ ] Serverless infrastructure used?
- [ ] TypeScript used for backend?
- [ ] Secrets handled securely?
- [ ] Error handling implemented?
- [ ] Tests added/updated?
- [ ] Performance requirements met?
- [ ] Documentation updated?

## References

- **Detailed docs**: See `AGENTS.md` for agent architecture, responsibilities, deployment workflow
- **Requirements**: See `PRD.md` for project requirements
- **External docs**: MedusaJS 2.0, Neon API, Google Cloud Run, Cloudflare for SaaS (see `AGENTS.md` Resources section)
